import deepmerge from 'deepmerge';
import { F as FileSystemConfigLoader, H as HtmlValidate, n as codeframe } from './core.js';
import kleur from 'kleur';
import { toMatchSnapshot, toMatchInlineSnapshot } from 'jest-snapshot';
import * as jestDiffDefault from 'jest-diff';
import jestDiffDefault__default from 'jest-diff';
import 'fs';
import 'path';
import '@sidvind/better-ajv-errors';
import 'ajv';
import '@babel/code-frame';

/* eslint-disable @typescript-eslint/ban-ts-comment */
/* ignore typing for compatibility so it will seem "impossible" but different version will yield different source */
const diffCandidates = [
    // @ts-ignore
    jestDiffDefault__default === null || jestDiffDefault__default === void 0 ? void 0 : jestDiffDefault__default.diff,
    // @ts-ignore
    jestDiffDefault__default,
    // @ts-ignore
    jestDiffDefault === null || jestDiffDefault === void 0 ? void 0 : jestDiffDefault.diff,
    // @ts-ignore
    jestDiffDefault,
];
const isFunction = (fn) => typeof fn === "function";
/* eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- assume one of the candidate matches, there will be a reasonable error later on if not */
const diff = diffCandidates.find(isFunction);

function isThenable(src) {
    return src && typeof src === "object" && typeof src.then === "function";
}

/**
 * Creates a wrapped function based on the passed function.
 *
 * The returned function takes either a `T` or `Promise<T>`. If `T` the result
 * will be synchronous or if `Promise<T>` the result will be asynchronous.
 *
 * In practice this means that if you pass a synchronous object into it you will
 * maintain synchronous code but if you pass an asynchronous object you must
 * await the result.
 */
function diverge(fn) {
    function diverged(actual, ...args) {
        if (isThenable(actual)) {
            return actual.then((resolved) => fn.call(this, resolved, ...args));
        }
        else {
            return fn.call(this, actual, ...args);
        }
    }
    return diverged;
}

/**
 * Takes all messages from all files and flattens to a single array.
 */
function flattenMessages(report) {
    return report.results.reduce((aggregated, result) => {
        return aggregated.concat(result.messages);
    }, []);
}

function toBeValid(report) {
    if (report.valid) {
        return {
            pass: true,
            message: /* istanbul ignore next */ () => "Result should not contain error",
        };
    }
    else {
        const firstError = report.results[0].messages[0];
        return {
            pass: false,
            message: () => `Result should be valid but had error "${firstError.message}"`,
        };
    }
}
var toBeValid$1 = diverge(toBeValid);

function toBeInvalid(report) {
    if (report.valid) {
        return {
            pass: false,
            message: () => "Result should be invalid but had no errors",
        };
    }
    else {
        return {
            pass: true,
            message: /* istanbul ignore next */ () => "Result should not contain error",
        };
    }
}
var toBeInvalid$1 = diverge(toBeInvalid);

/* eslint-disable @typescript-eslint/ban-ts-comment, prefer-template */
function isMessage(arg) {
    if (!arg) {
        return false;
    }
    return Boolean(arg.ruleId ||
        arg.severity ||
        arg.message ||
        arg.offset ||
        arg.line ||
        arg.column ||
        arg.size ||
        arg.selector ||
        arg.context);
}
function isConfig(arg) {
    if (!arg) {
        return false;
    }
    return Boolean(arg.root || arg.extends || arg.elements || arg.plugin || arg.transform || arg.rules);
}
function isString(arg) {
    return typeof arg === "string";
}
function getMarkup(src) {
    // @ts-ignore DOM library not available
    if (typeof HTMLElement !== "undefined" && src instanceof HTMLElement) {
        /* eslint-disable-next-line @typescript-eslint/no-unsafe-return */
        return src.outerHTML;
    }
    /* istanbul ignore else: prototype only allows string or HTMLElement */
    if (typeof src === "string") {
        return src;
    }
    else {
        throw new Error(`Failed to get markup from "${typeof src}" argument`);
    }
}
function toHTMLValidate(actual, arg0, arg1, arg2) {
    const markup = getMarkup(actual);
    const message = isMessage(arg0) ? arg0 : undefined;
    const config = isConfig(arg0) ? arg0 : isConfig(arg1) ? arg1 : undefined;
    const filename = isString(arg0) ? arg0 : isString(arg1) ? arg1 : arg2;
    return toHTMLValidateImpl.call(this, markup, message, config, filename);
}
function toHTMLValidateImpl(actual, expectedError, userConfig, filename) {
    const defaultConfig = {
        rules: {
            /* jsdom normalizes style so disabling rule when using this matcher or it
             * gets quite noisy when configured with self-closing */
            "void-style": "off",
        },
    };
    const config = deepmerge(defaultConfig, userConfig || {});
    const actualFilename = filename || this.testPath;
    const loader = new FileSystemConfigLoader({
        extends: ["html-validate:recommended"],
    });
    const htmlvalidate = new HtmlValidate(loader);
    const report = htmlvalidate.validateString(actual, actualFilename, config);
    const pass = report.valid;
    if (pass) {
        return { pass, message: () => "HTML is valid when an error was expected" };
    }
    else {
        if (expectedError) {
            const matcher = expect.arrayContaining([expect.objectContaining(expectedError)]);
            const errorPass = this.equals(report.results[0].messages, matcher);
            const diffString = diff(matcher, report.results[0].messages, {
                expand: this.expand,
                aAnnotation: "Expected error",
                bAnnotation: "Actual error",
            });
            const hint = this.utils.matcherHint(".not.toHTMLValidate", undefined, undefined, {
                comment: "expected error",
            });
            const expectedErrorMessage = () => [
                hint,
                "",
                "Expected error to be present:",
                this.utils.printExpected(expectedError),
                /* istanbul ignore next */ diffString ? `\n${diffString}` : "",
            ].join("\n");
            return { pass: !errorPass, message: expectedErrorMessage };
        }
        const errors = report.results[0].messages.map((message) => `  ${message.message} [${message.ruleId}]`);
        return {
            pass,
            message: () => ["Expected HTML to be valid but had the following errors:", ""].concat(errors).join("\n"),
        };
    }
}
var toHTMLValidate$1 = diverge(toHTMLValidate);

function toHaveErrorImpl(jest, actual, expected) {
    const flattened = flattenMessages(actual);
    const matcher = [expect.objectContaining(expected)];
    const pass = jest.equals(flattened, matcher);
    const diffString = diff(matcher, flattened, { expand: jest.expand });
    const hint = jest.utils.matcherHint(".toHaveError");
    const prettyExpected = jest.utils.printExpected(matcher);
    const prettyReceived = jest.utils.printReceived(flattened);
    const resultMessage = () => {
        return [
            hint,
            "",
            "Expected error to equal:",
            `  ${prettyExpected}`,
            "Received:",
            `  ${prettyReceived}`,
            /* istanbul ignore next */ diffString ? `\nDifference:\n\n${diffString}` : "",
        ].join("\n");
    };
    return { pass, message: resultMessage };
}
function toHaveError(actual, arg1, arg2, arg3 // eslint-disable-line @typescript-eslint/explicit-module-boundary-types
) {
    if (typeof arg1 === "string") {
        const expected = {
            ruleId: arg1,
            message: arg2,
        };
        if (arg3) {
            expected.context = arg3;
        }
        return toHaveErrorImpl(this, actual, expected);
    }
    else {
        return toHaveErrorImpl(this, actual, arg1);
    }
}
var toHaveError$1 = diverge(toHaveError);

/* eslint-disable prefer-template */
function toHaveErrors(report, errors) {
    const flattened = flattenMessages(report);
    const matcher = errors.map((entry) => {
        if (Array.isArray(entry)) {
            const [ruleId, message] = entry;
            /* eslint-disable-next-line @typescript-eslint/no-unsafe-return */
            return expect.objectContaining({ ruleId, message });
        }
        else {
            /* eslint-disable-next-line @typescript-eslint/no-unsafe-return */
            return expect.objectContaining(entry);
        }
    });
    const pass = this.equals(flattened, matcher);
    const diffString = diff(matcher, flattened, { expand: this.expand });
    const resultMessage = () => this.utils.matcherHint(".toHaveErrors") +
        "\n\n" +
        "Expected error to equal:\n" +
        `  ${this.utils.printExpected(matcher)}\n` +
        "Received:\n" +
        `  ${this.utils.printReceived(flattened)}` +
        /* istanbul ignore next */ (diffString ? `\n\nDifference:\n\n${diffString}` : "");
    return { pass, message: resultMessage };
}
var toHaveErrors$1 = diverge(toHaveErrors);

/**
 * @internal
 */
function getResults(filename, value) {
    if (typeof value === "string") {
        const loader = new FileSystemConfigLoader({
            extends: ["html-validate:recommended"],
        });
        const htmlvalidate = new HtmlValidate(loader);
        const report = htmlvalidate.validateString(value, filename, {
            rules: {
                "void-style": "off",
            },
        });
        return report.results.map((it) => {
            return { ...it, filePath: "inline" };
        });
    }
    else {
        return value.results;
    }
}

const options$1 = {
    showLink: false,
    showSummary: false,
    showSelector: true,
};
function toMatchCodeframe(actual, ...rest) {
    const filename = this.testPath;
    const results = getResults(filename, actual);
    const enabled = kleur.enabled;
    kleur.enabled = false;
    const snapshot = codeframe(results, options$1).replace(/\s+$/gm, "");
    kleur.enabled = enabled;
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-return, @typescript-eslint/no-unsafe-call */
    return toMatchSnapshot.call(this, snapshot, ...rest);
}

const options = {
    showLink: false,
    showSummary: false,
    showSelector: true,
};
function toMatchInlineCodeframe(actual, ...rest) {
    const filename = this.testPath;
    const results = getResults(filename, actual);
    const enabled = kleur.enabled;
    kleur.enabled = false;
    const snapshot = codeframe(results, options).replace(/\s+$/gm, "");
    kleur.enabled = enabled;
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-return, @typescript-eslint/no-unsafe-call */
    return toMatchInlineSnapshot.call(this, snapshot, ...rest);
}

export { toBeInvalid$1 as a, toHaveError$1 as b, toHaveErrors$1 as c, toHTMLValidate$1 as d, toMatchCodeframe as e, toMatchInlineCodeframe as f, toBeValid$1 as t };
//# sourceMappingURL=jest-lib.js.map
